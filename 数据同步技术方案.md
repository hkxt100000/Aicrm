# 企业微信 CRM 与自有系统数据同步技术方案

> 版本：v1.0  
> 日期：2026-01-24  
> 状态：待评审  

---

## 📋 目录

1. [方案概述](#方案概述)
2. [系统架构](#系统架构)
3. [接口规范](#接口规范)
4. [实施分工](#实施分工)
5. [数据流程](#数据流程)
6. [技术实现](#技术实现)
7. [测试方案](#测试方案)
8. [上线计划](#上线计划)

---

## 方案概述

### 业务目标

实现**自有业务系统**与**企业微信 CRM**的订单数据**双向实时同步**，确保两个系统数据一致性。

### 核心功能

| 功能 | 说明 | 优先级 |
|------|------|--------|
| **实时推送** | 自有系统订单变化 → 企业微信 CRM | P0 |
| **状态同步** | 订单状态变化实时推送 | P0 |
| **双向同步** | 企业微信字段变化 → 自有系统 | P1 |
| **数据巡查** | 每日凌晨自动对账，确保一致性 | P1 |
| **异常告警** | 同步失败/数据不一致时告警 | P1 |

### 业务场景

#### 场景 1：新增订单
```
自有系统：创建订单 ORD001
    ↓ 立即推送
企业微信 CRM：自动创建对应记录
    ↓
智能表格：显示新订单
```

#### 场景 2：订单状态变更
```
自有系统：订单 ORD001 状态变为"已发货"
    ↓ 实时推送
企业微信 CRM：更新对应记录状态
    ↓
智能表格：状态列自动更新
```

#### 场景 3：企业微信手动修改
```
企业微信：手动修改订单备注
    ↓ Webhook 回调
企业微信 CRM：接收变更通知
    ↓ 推送
自有系统：同步更新备注
```

#### 场景 4：数据巡查
```
凌晨 03:00
企业微信 CRM 定时任务启动
    ↓
对比双方订单数据
    ↓
发现不一致 → 发送告警 + 自动修复
```

---

## 系统架构

### 整体架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                          数据同步架构                              │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┐         ┌─────────────────┐         ┌─────────────────┐
│   自有业务系统   │◄───────►│ 企业微信 CRM     │◄───────►│  企业微信服务器   │
│                 │         │                 │         │                 │
│ • 订单管理      │   ①②    │ • 数据转换      │   ③④    │ • 智能表格      │
│ • 客户管理      │ Webhook │ • 同步控制      │  API    │ • 文档管理      │
│ • 库存管理      │   HTTP  │ • 任务调度      │  调用   │ • Webhook回调   │
│                 │         │ • 异常处理      │         │                 │
└─────────────────┘         └─────────────────┘         └─────────────────┘
        │                            │                            │
        │                            │                            │
        ▼                            ▼                            ▼
┌─────────────────┐         ┌─────────────────┐         ┌─────────────────┐
│   MySQL 数据库   │         │  SQLite 数据库   │         │  云端存储        │
│                 │         │                 │         │                 │
│ • 订单表        │         │ • 同步日志      │         │ • 表格数据      │
│ • 客户表        │         │ • 映射关系      │         │ • 操作记录      │
│ • 商品表        │         │ • 任务队列      │         │                 │
└─────────────────┘         └─────────────────┘         └─────────────────┘
```

### 数据流向

#### ① 自有系统 → 企业微信 CRM（实时推送）
```
自有系统订单变化
    ↓ POST /api/webhook/order/sync
企业微信 CRM 接收
    ↓ 数据验证 + 转换
    ↓ POST /cgi-bin/wedoc/smartsheet/add_records
企业微信 API
    ↓ 返回结果
企业微信 CRM 记录日志
    ↓ 成功/失败通知
自有系统接收响应
```

#### ② 自有系统查询接口（数据巡查用）
```
企业微信 CRM 定时任务
    ↓ GET /api/orders/list?date=2026-01-24
自有系统返回订单列表
    ↓ 对比数据
企业微信 CRM 检查一致性
    ↓ 如有差异
发送告警 + 自动修复
```

#### ③ 企业微信 → 企业微信 CRM（Webhook 回调）
```
用户在企业微信修改数据
    ↓ 触发 Webhook
企业微信回调
    ↓ POST /api/webhook/wecom/callback
企业微信 CRM 接收
    ↓ 解析变更内容
识别字段变化
```

#### ④ 企业微信 CRM → 自有系统（反向同步）
```
企业微信 CRM 检测到字段变化
    ↓ 转换为自有系统格式
    ↓ POST /api/orders/update
自有系统更新数据
    ↓ 返回结果
企业微信 CRM 记录日志
```

---

## 接口规范

### 自有系统需要提供的接口

#### 接口 1：订单推送（实时）⭐核心接口

**用途**：自有系统新增/修改订单时，主动推送到企业微信 CRM

**接口地址**：
```
POST http://企业微信CRM服务器IP:9999/api/webhook/order/sync
```

**请求头**：
```http
Content-Type: application/json
Authorization: Bearer {SECRET_TOKEN}
```

**请求参数**：
```json
{
  "action": "add",                    // 必填：add=新增, update=更新, delete=删除
  "order_id": "ORD20260124001",      // 必填：订单ID（唯一标识）
  "timestamp": 1706064000,            // 必填：操作时间戳（秒）
  "data": {
    "下单时间": "2026-01-24 10:00:00",
    "更新时间": "2026-01-24 10:00:00",
    "订单ID": "ORD20260124001",
    "外部订单号": "EXT123456",
    "上游订单号": "UP789012",
    "下单来源": "app",
    "订单归属人": "张三",
    "订单归属上级": "李四",
    "归属人类型": "个人",
    "商务账号": "账号001",
    "订单状态": "待发货",           // ⭐ 重点：状态字段
    "订单金额": "1500.00",
    "客户姓名": "王五",
    "客户电话": "13800138000",
    "收货地址": "北京市朝阳区...",
    "备注": "客户要求尽快发货"
    // ... 其他44个字段
  },
  "changed_fields": ["订单状态"]    // 可选：本次变更的字段列表（用于update）
}
```

**响应示例**：
```json
{
  "success": true,
  "message": "同步成功",
  "sync_id": "SYNC20260124001",      // 同步记录ID
  "wecom_record_id": "REC123456",    // 企业微信记录ID
  "timestamp": 1706064001
}
```

**错误响应**：
```json
{
  "success": false,
  "message": "同步失败：订单ID重复",
  "error_code": "DUPLICATE_ORDER",
  "timestamp": 1706064001
}
```

**调用示例（PHP）**：
```php
<?php
// 自有系统：订单创建/更新时调用

function syncOrderToWecom($action, $orderId, $orderData, $changedFields = []) {
    $url = 'http://企业微信CRM服务器IP:9999/api/webhook/order/sync';
    $token = 'your-secret-token-here';  // 预先约定的密钥
    
    $payload = [
        'action' => $action,
        'order_id' => $orderId,
        'timestamp' => time(),
        'data' => $orderData,
        'changed_fields' => $changedFields
    ];
    
    $ch = curl_init($url);
    curl_setopt($ch, CURLOPT_POST, true);
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
    curl_setopt($ch, CURLOPT_HTTPHEADER, [
        'Content-Type: application/json',
        'Authorization: Bearer ' . $token
    ]);
    curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($payload));
    
    $response = curl_exec($ch);
    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
    curl_close($ch);
    
    if ($httpCode === 200) {
        $result = json_decode($response, true);
        if ($result['success']) {
            // 同步成功，记录日志
            error_log("订单同步成功：{$orderId}");
            return true;
        } else {
            // 同步失败，记录错误
            error_log("订单同步失败：{$result['message']}");
            return false;
        }
    } else {
        // HTTP 错误
        error_log("订单同步HTTP错误：{$httpCode}");
        return false;
    }
}

// 使用示例
// 1. 新增订单时
$orderData = [
    '下单时间' => '2026-01-24 10:00:00',
    '订单ID' => 'ORD20260124001',
    // ... 其他字段
];
syncOrderToWecom('add', 'ORD20260124001', $orderData);

// 2. 订单状态变更时
$orderData = [
    '订单状态' => '已发货',
    '更新时间' => '2026-01-24 15:00:00'
];
syncOrderToWecom('update', 'ORD20260124001', $orderData, ['订单状态']);
?>
```

---

#### 接口 2：订单列表查询（数据巡查用）

**用途**：企业微信 CRM 定时拉取订单列表，用于数据一致性检查

**接口地址**：
```
GET http://自有系统域名/api/orders/list
```

**请求头**：
```http
Authorization: Bearer {API_TOKEN}
```

**请求参数**：
```
?date=2026-01-24          // 必填：查询日期（YYYY-MM-DD）
&page=1                   // 可选：页码，默认1
&page_size=100            // 可选：每页数量，默认100
```

**响应示例**：
```json
{
  "success": true,
  "total": 150,
  "page": 1,
  "page_size": 100,
  "data": [
    {
      "order_id": "ORD20260124001",
      "下单时间": "2026-01-24 10:00:00",
      "更新时间": "2026-01-24 15:00:00",
      "订单状态": "已发货",
      // ... 所有字段
      "md5": "abc123..."   // 可选：数据MD5，用于快速对比
    },
    // ... 更多订单
  ]
}
```

---

#### 接口 3：订单更新（反向同步）

**用途**：企业微信用户修改数据后，推送回自有系统

**接口地址**：
```
POST http://自有系统域名/api/orders/update
```

**请求头**：
```http
Content-Type: application/json
Authorization: Bearer {API_TOKEN}
```

**请求参数**：
```json
{
  "order_id": "ORD20260124001",
  "source": "wecom",              // 固定值：wecom
  "timestamp": 1706064000,
  "changed_fields": {
    "备注": "客户已签收",
    "更新时间": "2026-01-24 18:00:00"
  }
}
```

**响应示例**：
```json
{
  "success": true,
  "message": "更新成功"
}
```

---

### 企业微信 CRM 需要提供的接口

#### 接口 1：Webhook 接收（自有系统推送用）

**接口地址**：
```
POST http://企业微信CRM服务器IP:9999/api/webhook/order/sync
```

**功能**：
- 接收自有系统推送的订单数据
- 验证请求签名/Token
- 数据转换（自有系统格式 → 企业微信格式）
- 调用企业微信 API 添加/更新记录
- 返回同步结果

---

#### 接口 2：企业微信 Webhook 回调接收

**接口地址**：
```
POST http://企业微信CRM服务器IP:9999/api/webhook/wecom/callback
```

**功能**：
- 接收企业微信的数据变更通知
- 解析变更内容
- 推送到自有系统

---

### 企业微信官方 API（已有）

#### API 1：添加记录
```
POST https://qyapi.weixin.qq.com/cgi-bin/wedoc/smartsheet/add_records
```

#### API 2：更新记录
```
PATCH https://qyapi.weixin.qq.com/cgi-bin/wedoc/smartsheet/update_records
```

#### API 3：查询记录
```
GET https://qyapi.weixin.qq.com/cgi-bin/wedoc/smartsheet/get_records
```

---

## 实施分工

### 自有系统技术部门职责

#### 阶段一：接口开发（预计 3-5 天）

| 任务 | 说明 | 工作量 | 负责人 |
|------|------|--------|--------|
| **订单推送接口集成** | 在订单创建/更新时调用企业微信CRM接口 | 2天 | 后端工程师 |
| **订单列表查询接口** | 提供按日期查询订单列表的API | 1天 | 后端工程师 |
| **订单更新接口** | 接收企业微信的反向同步请求 | 1天 | 后端工程师 |
| **异常重试机制** | 推送失败时的重试逻辑 | 1天 | 后端工程师 |

#### 开发要点

**1. 订单推送时机**

在以下时机调用 `syncOrderToWecom()`：

```php
// 场景 1：创建订单后
function createOrder($orderData) {
    // 1. 插入订单到数据库
    $orderId = $db->insert('orders', $orderData);
    
    // 2. 立即推送到企业微信 CRM
    syncOrderToWecom('add', $orderId, $orderData);
    
    return $orderId;
}

// 场景 2：订单状态变更
function updateOrderStatus($orderId, $newStatus) {
    // 1. 更新数据库
    $db->update('orders', ['status' => $newStatus], ['id' => $orderId]);
    
    // 2. 获取完整订单数据
    $orderData = $db->select('orders', ['id' => $orderId]);
    
    // 3. 推送变更
    syncOrderToWecom('update', $orderId, $orderData, ['订单状态']);
}

// 场景 3：订单任意字段修改
function updateOrder($orderId, $updateData) {
    // 1. 更新数据库
    $db->update('orders', $updateData, ['id' => $orderId]);
    
    // 2. 获取完整订单数据
    $orderData = $db->select('orders', ['id' => $orderId]);
    
    // 3. 推送变更（指定变更字段）
    $changedFields = array_keys($updateData);
    syncOrderToWecom('update', $orderId, $orderData, $changedFields);
}
```

**2. 异常处理**

```php
function syncOrderToWecom($action, $orderId, $orderData, $changedFields = []) {
    $maxRetries = 3;  // 最多重试3次
    $retryDelay = 5;  // 重试间隔5秒
    
    for ($i = 0; $i < $maxRetries; $i++) {
        $result = callWecomCRM($action, $orderId, $orderData, $changedFields);
        
        if ($result['success']) {
            // 成功，记录日志
            logSync($orderId, 'success', $result);
            return true;
        }
        
        // 失败，判断是否需要重试
        if (shouldRetry($result['error_code'])) {
            sleep($retryDelay);
            continue;
        } else {
            // 不可重试的错误（如数据格式错误），直接放弃
            logSync($orderId, 'failed', $result);
            return false;
        }
    }
    
    // 重试耗尽，记录失败
    logSync($orderId, 'failed_after_retries', $result);
    
    // 可选：加入重试队列，稍后批量处理
    addToRetryQueue($orderId, $action, $orderData);
    
    return false;
}
```

**3. 字段映射配置**

建议在配置文件中维护字段映射关系：

```php
// config/field_mapping.php
return [
    // 自有系统字段名 => 企业微信字段名
    'create_time' => '下单时间',
    'update_time' => '更新时间',
    'order_no' => '订单ID',
    'external_order_no' => '外部订单号',
    'upstream_order_no' => '上游订单号',
    'order_source' => '下单来源',
    'order_owner' => '订单归属人',
    'order_superior' => '订单归属上级',
    'owner_type' => '归属人类型',
    'business_account' => '商务账号',
    'order_status' => '订单状态',
    'order_amount' => '订单金额',
    'customer_name' => '客户姓名',
    'customer_phone' => '客户电话',
    'delivery_address' => '收货地址',
    'remark' => '备注',
    // ... 其他字段映射
];

// 使用映射转换数据
function convertToWecomFormat($orderData) {
    $fieldMapping = require 'config/field_mapping.php';
    $wecomData = [];
    
    foreach ($orderData as $key => $value) {
        if (isset($fieldMapping[$key])) {
            $wecomData[$fieldMapping[$key]] = $value;
        }
    }
    
    return $wecomData;
}
```

---

### 企业微信 CRM 技术职责

#### 阶段一：接口开发（预计 3-5 天）

| 任务 | 说明 | 工作量 | 负责人 |
|------|------|--------|--------|
| **Webhook 接收接口** | 接收自有系统推送的订单数据 | 1天 | 后端工程师 |
| **数据转换逻辑** | 自有系统格式 → 企业微信格式 | 1天 | 后端工程师 |
| **企业微信 API 调用** | 添加/更新智能表格记录 | 1天 | 后端工程师 |
| **同步日志记录** | 记录所有同步操作和结果 | 0.5天 | 后端工程师 |
| **异常告警** | 同步失败时发送告警通知 | 0.5天 | 后端工程师 |

#### 阶段二：数据巡查（预计 2-3 天）

| 任务 | 说明 | 工作量 | 负责人 |
|------|------|--------|--------|
| **定时任务调度** | 每日凌晨定时执行巡查 | 0.5天 | 后端工程师 |
| **数据对比逻辑** | 对比双方订单数据一致性 | 1天 | 后端工程师 |
| **自动修复** | 发现不一致时自动修复 | 1天 | 后端工程师 |
| **巡查报告** | 生成每日巡查报告 | 0.5天 | 后端工程师 |

#### 阶段三：反向同步（预计 2-3 天）

| 任务 | 说明 | 工作量 | 负责人 |
|------|------|--------|--------|
| **企业微信 Webhook 配置** | 配置企业微信回调URL | 0.5天 | 后端工程师 |
| **回调接收和解析** | 接收企业微信变更通知 | 1天 | 后端工程师 |
| **推送到自有系统** | 将变更推送到自有系统 | 1天 | 后端工程师 |

---

## 数据流程

### 流程 1：订单新增同步

```
┌─────────────────────────────────────────────────────────────────┐
│                        订单新增同步流程                            │
└─────────────────────────────────────────────────────────────────┘

自有系统                      企业微信 CRM                  企业微信服务器
    │                              │                              │
    │ 1. 用户下单                  │                              │
    │ createOrder()                │                              │
    │                              │                              │
    │ 2. 推送订单数据              │                              │
    ├─────POST /webhook/sync──────>│                              │
    │   {action: "add", ...}       │                              │
    │                              │ 3. 验证 Token                │
    │                              │ ✓ 验证通过                   │
    │                              │                              │
    │                              │ 4. 数据转换                  │
    │                              │ 自有格式 → 企业微信格式       │
    │                              │                              │
    │                              │ 5. 调用企业微信 API           │
    │                              ├────add_records───────────────>│
    │                              │                              │
    │                              │                              │ 6. 创建记录
    │                              │                              │ ✓ 成功
    │                              │                              │
    │                              │<────成功响应──────────────────┤
    │                              │ {errcode: 0}                 │
    │                              │                              │
    │                              │ 7. 记录同步日志              │
    │                              │ 保存到 sync_logs 表          │
    │                              │                              │
    │<────200 OK────────────────────┤                              │
    │ {success: true,              │                              │
    │  sync_id: "SYNC001"}         │                              │
    │                              │                              │
    │ 8. 记录本地日志              │                              │
    │ ✓ 同步成功                   │                              │
    │                              │                              │
```

### 流程 2：订单状态变更同步

```
自有系统                      企业微信 CRM                  企业微信服务器
    │                              │                              │
    │ 1. 订单状态变更              │                              │
    │ updateOrderStatus()          │                              │
    │ "待发货" → "已发货"          │                              │
    │                              │                              │
    │ 2. 推送变更                  │                              │
    ├─────POST /webhook/sync──────>│                              │
    │   {action: "update",         │                              │
    │    changed_fields:            │                              │
    │      ["订单状态"]}            │                              │
    │                              │ 3. 查询订单记录              │
    │                              │ 根据 order_id 查找           │
    │                              │ 企业微信 record_id           │
    │                              │                              │
    │                              │ 4. 调用更新 API              │
    │                              ├────update_records────────────>│
    │                              │ 只更新 "订单状态" 字段        │
    │                              │                              │
    │                              │                              │ 5. 更新记录
    │                              │                              │ ✓ 成功
    │                              │                              │
    │                              │<────成功响应──────────────────┤
    │                              │                              │
    │<────200 OK────────────────────┤                              │
    │                              │                              │
```

### 流程 3：数据巡查（每日凌晨）

```
┌─────────────────────────────────────────────────────────────────┐
│                        数据巡查流程                               │
└─────────────────────────────────────────────────────────────────┘

定时任务                      企业微信 CRM                  自有系统
    │                              │                              │
03:00 定时触发                     │                              │
    ├──────────────────────────────>│                              │
    │                              │                              │
    │                              │ 1. 获取昨日订单列表           │
    │                              ├────GET /api/orders/list─────>│
    │                              │ ?date=2026-01-23             │
    │                              │                              │
    │                              │                              │ 2. 查询数据库
    │                              │                              │
    │                              │<────返回订单列表──────────────┤
    │                              │ [订单1, 订单2, ...]          │
    │                              │                              │
    │                              │ 3. 查询企业微信数据           │
    │                              │ get_records(昨日)            │
    │                              │                              │
    │                              │ 4. 数据对比                  │
    │                              │ ┌─────────────────┐         │
    │                              │ │ 对比订单数量     │         │
    │                              │ │ 对比订单状态     │         │
    │                              │ │ 对比字段值       │         │
    │                              │ │ 对比 MD5         │         │
    │                              │ └─────────────────┘         │
    │                              │                              │
    │                              │ 5. 发现差异                  │
    │                              │ • 自有系统有，企业微信没有    │
    │                              │   → 自动补充到企业微信        │
    │                              │                              │
    │                              │ • 企业微信有，自有系统没有    │
    │                              │   → 发送告警（异常数据）      │
    │                              │                              │
    │                              │ • 字段值不一致               │
    │                              │   → 以自有系统为准，更新      │
    │                              │                              │
    │                              │ 6. 生成巡查报告              │
    │                              │ ┌─────────────────┐         │
    │                              │ │ 巡查时间: 03:00  │         │
    │                              │ │ 检查订单: 150条  │         │
    │                              │ │ 发现差异: 3条    │         │
    │                              │ │ 自动修复: 3条    │         │
    │                              │ │ 状态: 成功       │         │
    │                              │ └─────────────────┘         │
    │                              │                              │
    │                              │ 7. 发送报告                  │
    │                              │ （邮件/企业微信消息）         │
    │                              │                              │
```

### 流程 4：企业微信反向同步

```
企业微信服务器               企业微信 CRM                  自有系统
    │                              │                              │
    │ 1. 用户在企业微信修改         │                              │
    │ "备注" 字段                  │                              │
    │                              │                              │
    │ 2. 触发 Webhook               │                              │
    ├────POST /webhook/callback───>│                              │
    │ {                            │                              │
    │   docid: "DOC123",           │                              │
    │   record_id: "REC456",       │                              │
    │   changed_fields: {          │                              │
    │     "备注": "客户已签收"      │                              │
    │   }                          │                              │
    │ }                            │                              │
    │                              │ 3. 验证签名                  │
    │                              │ ✓ 验证通过                   │
    │                              │                              │
    │                              │ 4. 查询映射关系              │
    │                              │ record_id → order_id         │
    │                              │                              │
    │                              │ 5. 推送到自有系统             │
    │                              ├────POST /orders/update──────>│
    │                              │ {                            │
    │                              │   order_id: "ORD001",        │
    │                              │   changed_fields: {          │
    │                              │     "备注": "客户已签收"      │
    │                              │   }                          │
    │                              │ }                            │
    │                              │                              │
    │                              │                              │ 6. 更新数据库
    │                              │                              │ ✓ 成功
    │                              │                              │
    │                              │<────200 OK────────────────────┤
    │                              │                              │
    │                              │ 7. 记录同步日志              │
    │                              │                              │
```

---

## 技术实现

### 企业微信 CRM 代码实现

#### 1. Webhook 接收接口

```python
# wecom-crm/backend/app.py

from fastapi import APIRouter, Request, HTTPException, Header
from typing import Optional
import hashlib
import time

router = APIRouter()

# 预先约定的密钥
SECRET_TOKEN = "your-secret-token-here-change-in-production"

def verify_token(authorization: Optional[str]):
    """验证 Token"""
    if not authorization:
        raise HTTPException(status_code=401, detail="Missing Authorization header")
    
    try:
        scheme, token = authorization.split()
        if scheme.lower() != 'bearer':
            raise HTTPException(status_code=401, detail="Invalid authorization scheme")
        
        if token != SECRET_TOKEN:
            raise HTTPException(status_code=401, detail="Invalid token")
    except ValueError:
        raise HTTPException(status_code=401, detail="Invalid authorization header format")

@router.post("/api/webhook/order/sync")
async def webhook_order_sync(
    request: Request,
    authorization: Optional[str] = Header(None)
):
    """
    接收自有系统推送的订单数据
    """
    # 1. 验证 Token
    verify_token(authorization)
    
    # 2. 解析请求数据
    try:
        payload = await request.json()
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Invalid JSON: {str(e)}")
    
    # 3. 验证必填字段
    required_fields = ['action', 'order_id', 'timestamp', 'data']
    for field in required_fields:
        if field not in payload:
            raise HTTPException(status_code=400, detail=f"Missing required field: {field}")
    
    action = payload['action']
    order_id = payload['order_id']
    timestamp = payload['timestamp']
    data = payload['data']
    changed_fields = payload.get('changed_fields', [])
    
    # 4. 验证 action
    if action not in ['add', 'update', 'delete']:
        raise HTTPException(status_code=400, detail=f"Invalid action: {action}")
    
    # 5. 记录接收日志
    print(f"[Webhook] 接收订单同步请求: action={action}, order_id={order_id}")
    
    # 6. 调用同步处理函数
    try:
        result = await sync_order_to_wecom(action, order_id, data, changed_fields)
        
        return {
            "success": True,
            "message": "同步成功",
            "sync_id": result['sync_id'],
            "wecom_record_id": result['record_id'],
            "timestamp": int(time.time())
        }
    except Exception as e:
        print(f"[Webhook] 同步失败: {str(e)}")
        
        # 记录失败日志
        log_sync_error(order_id, action, str(e))
        
        return {
            "success": False,
            "message": f"同步失败: {str(e)}",
            "error_code": "SYNC_FAILED",
            "timestamp": int(time.time())
        }

async def sync_order_to_wecom(action: str, order_id: str, data: dict, changed_fields: list):
    """
    将订单同步到企业微信智能表格
    """
    # 1. 查询或创建智能表格
    docid = get_or_create_order_table()
    sheet_id = get_sheet_id(docid)
    
    # 2. 根据 action 执行不同操作
    if action == 'add':
        # 新增记录
        result = add_order_record(docid, sheet_id, order_id, data)
    elif action == 'update':
        # 更新记录
        result = update_order_record(docid, sheet_id, order_id, data, changed_fields)
    elif action == 'delete':
        # 删除记录
        result = delete_order_record(docid, sheet_id, order_id)
    
    # 3. 记录同步日志
    sync_id = log_sync_success(order_id, action, result)
    
    return {
        'sync_id': sync_id,
        'record_id': result.get('record_id')
    }

def add_order_record(docid: str, sheet_id: str, order_id: str, data: dict):
    """添加订单记录到企业微信"""
    access_token = wecom_client.get_access_token('app')
    
    # 转换数据格式
    record_values = {}
    for field_name, field_value in data.items():
        record_values[field_name] = [{
            "type": "text",
            "text": str(field_value)
        }]
    
    # 调用企业微信 API
    url = f"{wecom_client.api_base}/wedoc/smartsheet/add_records"
    response = requests.post(
        url,
        params={'access_token': access_token},
        json={
            "docid": docid,
            "sheet_id": sheet_id,
            "records": [{
                "values": record_values
            }]
        },
        timeout=30
    )
    
    result = response.json()
    
    if result.get('errcode') != 0:
        raise Exception(f"企业微信 API 错误: {result.get('errmsg')}")
    
    # 获取新记录的 record_id
    record_id = result.get('records', [{}])[0].get('record_id')
    
    # 保存映射关系
    save_order_mapping(order_id, docid, record_id)
    
    return {
        'record_id': record_id,
        'errcode': 0
    }

def update_order_record(docid: str, sheet_id: str, order_id: str, data: dict, changed_fields: list):
    """更新订单记录"""
    # 1. 查询 order_id 对应的 record_id
    mapping = get_order_mapping(order_id)
    if not mapping:
        raise Exception(f"订单 {order_id} 未找到映射记录")
    
    record_id = mapping['record_id']
    
    # 2. 准备更新数据（只更新变更的字段）
    record_values = {}
    
    if changed_fields:
        # 只更新指定字段
        for field_name in changed_fields:
            if field_name in data:
                record_values[field_name] = [{
                    "type": "text",
                    "text": str(data[field_name])
                }]
    else:
        # 更新所有字段
        for field_name, field_value in data.items():
            record_values[field_name] = [{
                "type": "text",
                "text": str(field_value)
            }]
    
    # 3. 调用企业微信 API
    access_token = wecom_client.get_access_token('app')
    url = f"{wecom_client.api_base}/wedoc/smartsheet/update_records"
    
    response = requests.post(
        url,
        params={'access_token': access_token},
        json={
            "docid": docid,
            "sheet_id": sheet_id,
            "records": [{
                "record_id": record_id,
                "values": record_values
            }]
        },
        timeout=30
    )
    
    result = response.json()
    
    if result.get('errcode') != 0:
        raise Exception(f"企业微信 API 错误: {result.get('errmsg')}")
    
    return {
        'record_id': record_id,
        'errcode': 0
    }

def delete_order_record(docid: str, sheet_id: str, order_id: str):
    """删除订单记录"""
    # 1. 查询映射
    mapping = get_order_mapping(order_id)
    if not mapping:
        raise Exception(f"订单 {order_id} 未找到映射记录")
    
    record_id = mapping['record_id']
    
    # 2. 调用企业微信 API
    access_token = wecom_client.get_access_token('app')
    url = f"{wecom_client.api_base}/wedoc/smartsheet/delete_records"
    
    response = requests.post(
        url,
        params={'access_token': access_token},
        json={
            "docid": docid,
            "sheet_id": sheet_id,
            "record_ids": [record_id]
        },
        timeout=30
    )
    
    result = response.json()
    
    if result.get('errcode') != 0:
        raise Exception(f"企业微信 API 错误: {result.get('errmsg')}")
    
    # 3. 删除映射记录
    delete_order_mapping(order_id)
    
    return {
        'record_id': record_id,
        'errcode': 0
    }

# 数据库操作函数

def save_order_mapping(order_id: str, docid: str, record_id: str):
    """保存订单ID和企业微信记录ID的映射关系"""
    conn = get_db()
    cursor = conn.cursor()
    
    cursor.execute("""
        INSERT OR REPLACE INTO order_mappings (
            order_id, docid, record_id, created_at, updated_at
        ) VALUES (?, ?, ?, ?, ?)
    """, (
        order_id, docid, record_id,
        int(time.time()), int(time.time())
    ))
    
    conn.commit()
    conn.close()

def get_order_mapping(order_id: str):
    """查询订单映射关系"""
    conn = get_db()
    cursor = conn.cursor()
    
    cursor.execute("""
        SELECT order_id, docid, record_id
        FROM order_mappings
        WHERE order_id = ?
    """, (order_id,))
    
    row = cursor.fetchone()
    conn.close()
    
    if row:
        return {
            'order_id': row[0],
            'docid': row[1],
            'record_id': row[2]
        }
    return None

def delete_order_mapping(order_id: str):
    """删除订单映射"""
    conn = get_db()
    cursor = conn.cursor()
    
    cursor.execute("DELETE FROM order_mappings WHERE order_id = ?", (order_id,))
    
    conn.commit()
    conn.close()

def log_sync_success(order_id: str, action: str, result: dict):
    """记录同步成功日志"""
    import uuid
    sync_id = str(uuid.uuid4())
    
    conn = get_db()
    cursor = conn.cursor()
    
    cursor.execute("""
        INSERT INTO sync_logs (
            sync_id, order_id, action, status, result, created_at
        ) VALUES (?, ?, ?, ?, ?, ?)
    """, (
        sync_id, order_id, action, 'success',
        json.dumps(result), int(time.time())
    ))
    
    conn.commit()
    conn.close()
    
    return sync_id

def log_sync_error(order_id: str, action: str, error: str):
    """记录同步失败日志"""
    import uuid
    sync_id = str(uuid.uuid4())
    
    conn = get_db()
    cursor = conn.cursor()
    
    cursor.execute("""
        INSERT INTO sync_logs (
            sync_id, order_id, action, status, error_message, created_at
        ) VALUES (?, ?, ?, ?, ?, ?)
    """, (
        sync_id, order_id, action, 'failed', error, int(time.time())
    ))
    
    conn.commit()
    conn.close()
```

#### 2. 数据库表结构

```sql
-- 订单映射表
CREATE TABLE IF NOT EXISTS order_mappings (
    order_id TEXT PRIMARY KEY,        -- 自有系统订单ID
    docid TEXT NOT NULL,               -- 企业微信文档ID
    record_id TEXT NOT NULL,           -- 企业微信记录ID
    created_at INTEGER NOT NULL,       -- 创建时间
    updated_at INTEGER NOT NULL        -- 更新时间
);

-- 同步日志表
CREATE TABLE IF NOT EXISTS sync_logs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    sync_id TEXT UNIQUE NOT NULL,      -- 同步ID（UUID）
    order_id TEXT NOT NULL,            -- 订单ID
    action TEXT NOT NULL,              -- 操作类型：add/update/delete
    status TEXT NOT NULL,              -- 状态：success/failed
    result TEXT,                       -- 成功响应（JSON）
    error_message TEXT,                -- 错误信息
    created_at INTEGER NOT NULL        -- 创建时间
);

CREATE INDEX idx_sync_logs_order_id ON sync_logs(order_id);
CREATE INDEX idx_sync_logs_created_at ON sync_logs(created_at);
```

#### 3. 数据巡查定时任务

```python
# wecom-crm/backend/scheduled_tasks.py

from apscheduler.schedulers.background import BackgroundScheduler
import requests
import hashlib

scheduler = BackgroundScheduler()

def start_scheduler():
    """启动定时任务"""
    # 每天凌晨 3:00 执行数据巡查
    scheduler.add_job(
        daily_data_check,
        'cron',
        hour=3,
        minute=0
    )
    
    scheduler.start()
    print("[定时任务] 已启动，每日 03:00 执行数据巡查")

async def daily_data_check():
    """每日数据巡查任务"""
    print("[巡查] 开始执行数据巡查...")
    
    # 1. 获取昨日日期
    from datetime import datetime, timedelta
    yesterday = (datetime.now() - timedelta(days=1)).strftime('%Y-%m-%d')
    
    # 2. 从自有系统获取昨日订单
    system_orders = fetch_orders_from_system(yesterday)
    print(f"[巡查] 自有系统订单数: {len(system_orders)}")
    
    # 3. 从企业微信获取昨日订单
    wecom_orders = fetch_orders_from_wecom(yesterday)
    print(f"[巡查] 企业微信订单数: {len(wecom_orders)}")
    
    # 4. 对比数据
    differences = compare_orders(system_orders, wecom_orders)
    
    # 5. 自动修复差异
    fixed_count = 0
    for diff in differences:
        try:
            fix_difference(diff)
            fixed_count += 1
        except Exception as e:
            print(f"[巡查] 修复失败: {diff['order_id']}, 错误: {str(e)}")
    
    # 6. 生成报告
    report = {
        'date': yesterday,
        'check_time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
        'system_count': len(system_orders),
        'wecom_count': len(wecom_orders),
        'differences_count': len(differences),
        'fixed_count': fixed_count,
        'status': 'success' if fixed_count == len(differences) else 'partial'
    }
    
    # 7. 保存报告
    save_check_report(report)
    
    # 8. 发送通知
    send_check_notification(report)
    
    print("[巡查] 数据巡查完成")

def fetch_orders_from_system(date: str):
    """从自有系统获取订单列表"""
    url = f"http://自有系统域名/api/orders/list?date={date}&page_size=1000"
    headers = {
        'Authorization': f'Bearer {SYSTEM_API_TOKEN}'
    }
    
    all_orders = []
    page = 1
    
    while True:
        response = requests.get(f"{url}&page={page}", headers=headers, timeout=30)
        data = response.json()
        
        if not data['success']:
            raise Exception(f"获取订单失败: {data.get('message')}")
        
        all_orders.extend(data['data'])
        
        # 检查是否还有下一页
        if page * data['page_size'] >= data['total']:
            break
        
        page += 1
    
    return all_orders

def fetch_orders_from_wecom(date: str):
    """从企业微信获取订单列表"""
    docid = get_order_table_docid()
    sheet_id = get_sheet_id(docid)
    
    access_token = wecom_client.get_access_token('app')
    url = f"{wecom_client.api_base}/wedoc/smartsheet/get_records"
    
    # 获取所有记录（可能需要分页）
    all_records = []
    offset = 0
    limit = 100
    
    while True:
        response = requests.get(
            url,
            params={
                'access_token': access_token,
                'docid': docid,
                'sheet_id': sheet_id,
                'offset': offset,
                'limit': limit
            },
            timeout=30
        )
        
        result = response.json()
        
        if result.get('errcode') != 0:
            raise Exception(f"企业微信 API 错误: {result.get('errmsg')}")
        
        records = result.get('records', [])
        all_records.extend(records)
        
        if len(records) < limit:
            break
        
        offset += limit
    
    # 过滤昨日订单（根据"下单时间"字段）
    yesterday_orders = []
    for record in all_records:
        order_time = record['values'].get('下单时间', [{}])[0].get('text', '')
        if order_time.startswith(date):
            yesterday_orders.append(record)
    
    return yesterday_orders

def compare_orders(system_orders, wecom_orders):
    """对比订单数据，找出差异"""
    differences = []
    
    # 建立企业微信订单的快速查找字典
    wecom_dict = {}
    for order in wecom_orders:
        order_id = order['values'].get('订单ID', [{}])[0].get('text', '')
        wecom_dict[order_id] = order
    
    # 检查自有系统中的每个订单
    for system_order in system_orders:
        order_id = system_order['订单ID']
        
        if order_id not in wecom_dict:
            # 企业微信中没有这个订单
            differences.append({
                'type': 'missing_in_wecom',
                'order_id': order_id,
                'data': system_order
            })
        else:
            # 对比字段值
            wecom_order = wecom_dict[order_id]
            field_diffs = compare_order_fields(system_order, wecom_order)
            
            if field_diffs:
                differences.append({
                    'type': 'field_mismatch',
                    'order_id': order_id,
                    'field_diffs': field_diffs,
                    'system_data': system_order,
                    'wecom_data': wecom_order
                })
    
    # 检查企业微信中多余的订单
    for order_id, wecom_order in wecom_dict.items():
        system_order_ids = [o['订单ID'] for o in system_orders]
        if order_id not in system_order_ids:
            differences.append({
                'type': 'extra_in_wecom',
                'order_id': order_id,
                'data': wecom_order
            })
    
    return differences

def compare_order_fields(system_order, wecom_order):
    """对比订单字段值"""
    field_diffs = []
    
    for field_name, system_value in system_order.items():
        wecom_value = wecom_order['values'].get(field_name, [{}])[0].get('text', '')
        
        # 标准化值（去除空格、统一大小写等）
        system_value_std = str(system_value).strip()
        wecom_value_std = str(wecom_value).strip()
        
        if system_value_std != wecom_value_std:
            field_diffs.append({
                'field_name': field_name,
                'system_value': system_value,
                'wecom_value': wecom_value
            })
    
    return field_diffs

def fix_difference(diff):
    """修复数据差异"""
    diff_type = diff['type']
    order_id = diff['order_id']
    
    if diff_type == 'missing_in_wecom':
        # 企业微信中缺少订单，自动添加
        print(f"[巡查] 修复：添加订单 {order_id} 到企业微信")
        sync_order_to_wecom('add', order_id, diff['data'], [])
    
    elif diff_type == 'field_mismatch':
        # 字段值不一致，以自有系统为准，更新企业微信
        print(f"[巡查] 修复：更新订单 {order_id} 的字段")
        changed_fields = [f['field_name'] for f in diff['field_diffs']]
        sync_order_to_wecom('update', order_id, diff['system_data'], changed_fields)
    
    elif diff_type == 'extra_in_wecom':
        # 企业微信中多余的订单，发送告警（不自动删除）
        print(f"[巡查] 告警：企业微信中发现额外订单 {order_id}")
        send_alert(f"发现额外订单：{order_id}，请人工检查")

def save_check_report(report):
    """保存巡查报告"""
    conn = get_db()
    cursor = conn.cursor()
    
    cursor.execute("""
        INSERT INTO daily_check_reports (
            date, check_time, system_count, wecom_count,
            differences_count, fixed_count, status, report_data
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    """, (
        report['date'], report['check_time'],
        report['system_count'], report['wecom_count'],
        report['differences_count'], report['fixed_count'],
        report['status'], json.dumps(report)
    ))
    
    conn.commit()
    conn.close()

def send_check_notification(report):
    """发送巡查报告通知"""
    # 方式1：发送企业微信消息
    # 方式2：发送邮件
    # 方式3：写入日志文件
    
    message = f"""
【数据巡查报告】
日期: {report['date']}
巡查时间: {report['check_time']}
自有系统订单数: {report['system_count']}
企业微信订单数: {report['wecom_count']}
发现差异: {report['differences_count']}
自动修复: {report['fixed_count']}
状态: {report['status']}
"""
    
    print(message)
    # TODO: 实现实际的通知发送
```

#### 4. 在主程序中启动定时任务

```python
# wecom-crm/backend/app.py

from scheduled_tasks import start_scheduler

@app.on_event("startup")
async def startup_event():
    """应用启动时执行"""
    # 启动定时任务调度器
    start_scheduler()
    print("[应用] 定时任务调度器已启动")
```

---

## 测试方案

### 测试环境准备

1. **自有系统测试环境**
   - 准备测试数据库
   - 部署测试接口

2. **企业微信 CRM 测试环境**
   - 独立的测试表格
   - 测试用的 access_token

### 测试用例

#### 用例 1：订单新增同步

**步骤**：
1. 自有系统创建订单：`ORD_TEST_001`
2. 系统自动推送到企业微信 CRM
3. 检查企业微信表格是否有对应记录

**预期结果**：
- ✅ 企业微信表格中出现新记录
- ✅ 所有字段数据正确
- ✅ 同步日志记录成功

---

#### 用例 2：订单状态变更

**步骤**：
1. 修改订单 `ORD_TEST_001` 状态：`待发货` → `已发货`
2. 系统推送变更
3. 检查企业微信表格

**预期结果**：
- ✅ 企业微信中的订单状态已更新
- ✅ 只有状态字段变更，其他字段不变
- ✅ 同步日志记录正确

---

#### 用例 3：并发同步

**步骤**：
1. 同时创建 100 个订单
2. 批量推送到企业微信 CRM

**预期结果**：
- ✅ 所有订单都成功同步
- ✅ 无数据丢失
- ✅ 无重复记录

---

#### 用例 4：网络异常重试

**步骤**：
1. 模拟网络故障（断开企业微信 CRM 连接）
2. 创建订单并推送
3. 恢复网络
4. 检查重试机制

**预期结果**：
- ✅ 自动重试 3 次
- ✅ 重试成功后数据同步
- ✅ 失败记录进入重试队列

---

#### 用例 5：数据巡查

**步骤**：
1. 手动删除企业微信中的 1 条记录
2. 触发数据巡查任务
3. 检查结果

**预期结果**：
- ✅ 检测到数据差异
- ✅ 自动补充缺失记录
- ✅ 生成巡查报告

---

#### 用例 6：反向同步

**步骤**：
1. 在企业微信表格中手动修改"备注"字段
2. 触发 Webhook 回调
3. 检查自有系统数据

**预期结果**：
- ✅ 自有系统的备注字段已更新
- ✅ 同步日志记录正确

---

## 上线计划

### 阶段 1：开发与测试（预计 2 周）

| 周次 | 任务 | 负责方 |
|------|------|--------|
| Week 1 | 接口开发 | 双方技术团队 |
| Week 2 | 联调测试 | 双方技术团队 |

### 阶段 2：灰度上线（预计 1 周）

| 步骤 | 说明 |
|------|------|
| Day 1-2 | 小流量测试（10% 订单） |
| Day 3-4 | 中流量测试（50% 订单） |
| Day 5-7 | 全量上线 |

### 阶段 3：稳定运行与监控

| 监控指标 | 告警阈值 |
|---------|---------|
| 同步成功率 | < 99% |
| 同步延迟 | > 5秒 |
| 数据一致性 | 差异 > 1% |

---

## 附录

### A. 字段映射表（示例）

| 自有系统字段名 | 企业微信字段名 | 数据类型 | 必填 |
|--------------|--------------|---------|------|
| create_time | 下单时间 | datetime | ✓ |
| update_time | 更新时间 | datetime | ✓ |
| order_no | 订单ID | text | ✓ |
| external_order_no | 外部订单号 | text | - |
| order_status | 订单状态 | text | ✓ |
| order_amount | 订单金额 | text | ✓ |
| customer_name | 客户姓名 | text | ✓ |
| remark | 备注 | text | - |

### B. 错误码定义

| 错误码 | 说明 | 处理方式 |
|--------|------|---------|
| INVALID_TOKEN | Token 验证失败 | 检查 Token 配置 |
| DUPLICATE_ORDER | 订单ID重复 | 检查是否已同步 |
| WECOM_API_ERROR | 企业微信API错误 | 查看详细错误信息 |
| NETWORK_TIMEOUT | 网络超时 | 自动重试 |

### C. 联系方式

| 角色 | 姓名 | 联系方式 |
|------|------|---------|
| 自有系统负责人 | - | - |
| 企业微信CRM负责人 | - | - |
| 项目经理 | - | - |

---

**文档版本**: v1.0  
**最后更新**: 2026-01-24  
**下次评审**: 待定  

